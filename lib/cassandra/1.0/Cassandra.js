//
// Autogenerated by Thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;

var ttypes = require('./cassandra_types');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args){
  this.auth_request = null
if( args != null ){  if (null != args.auth_request)
  this.auth_request = args.auth_request
}}
Cassandra_login_args.prototype = {}
Cassandra_login_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.auth_request = new ttypes.AuthenticationRequest()
        this.auth_request.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_login_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_login_args')
  if (null != this.auth_request) {
    output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 1)
    this.auth_request.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_login_result = function(args){
  this.authnx = null
  this.authzx = null
if( args != null ){  if (null != args.authnx)
  this.authnx = args.authnx
  if (null != args.authzx)
  this.authzx = args.authzx
}}
Cassandra_login_result.prototype = {}
Cassandra_login_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.authnx = new ttypes.AuthenticationException()
        this.authnx.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.authzx = new ttypes.AuthorizationException()
        this.authzx.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_login_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_login_result')
  if (null != this.authnx) {
    output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1)
    this.authnx.write(output)
    output.writeFieldEnd()
  }
  if (null != this.authzx) {
    output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2)
    this.authzx.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_set_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_set_keyspace_args.prototype = {}
Cassandra_set_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_set_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_set_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_set_keyspace_result = function(args){
  this.ire = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_set_keyspace_result.prototype = {}
Cassandra_set_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_set_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_set_keyspace_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_args = function(args){
  this.key = null
  this.column_path = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_path)
  this.column_path = args.column_path
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_args.prototype = {}
Cassandra_get_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath()
        this.column_path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2)
    this.column_path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_result = function(args){
  this.success = null
  this.ire = null
  this.nfe = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.nfe)
  this.nfe = args.nfe
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_result.prototype = {}
Cassandra_get_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.ColumnOrSuperColumn()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException()
        this.nfe.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2)
    this.nfe.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 4)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_slice_args = function(args){
  this.key = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_slice_args.prototype = {}
Cassandra_get_slice_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_slice_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_slice_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_slice_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_slice_result.prototype = {}
Cassandra_get_slice_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size147 = 0
          var rtmp3
          this.success = []
          var _etype150 = 0
          rtmp3 = input.readListBegin()
          _etype150 = rtmp3.etype
          _size147 = rtmp3.size
          for (var _i151 = 0; _i151 < _size147; ++_i151)
          {
            var elem152 = null
            elem152 = new ttypes.ColumnOrSuperColumn()
            elem152.read(input)
            this.success.push(elem152)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_slice_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_slice_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter153 in this.success)
        {
          if (this.success.hasOwnProperty(iter153))
          {
            iter153=this.success[iter153]
            iter153.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_count_args = function(args){
  this.key = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_count_args.prototype = {}
Cassandra_get_count_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_count_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_count_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_count_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_count_result.prototype = {}
Cassandra_get_count_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.I32) {
        this.success = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_count_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_count_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.I32, 0)
    output.writeI32(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_slice_args = function(args){
  this.keys = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.keys)
  this.keys = args.keys
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_multiget_slice_args.prototype = {}
Cassandra_multiget_slice_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size154 = 0
          var rtmp3
          this.keys = []
          var _etype157 = 0
          rtmp3 = input.readListBegin()
          _etype157 = rtmp3.etype
          _size154 = rtmp3.size
          for (var _i158 = 0; _i158 < _size154; ++_i158)
          {
            var elem159 = null
            elem159 = input.readString()
            this.keys.push(elem159)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_slice_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_slice_args')
  if (null != this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.keys.length)
      {
        for(var iter160 in this.keys)
        {
          if (this.keys.hasOwnProperty(iter160))
          {
            iter160=this.keys[iter160]
            output.writeString(iter160)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_slice_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_multiget_slice_result.prototype = {}
Cassandra_multiget_slice_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size161 = 0
          var rtmp3
          this.success = {}
          var _ktype162 = 0
          var _vtype163 = 0
          rtmp3 = input.readMapBegin()
          _ktype162= rtmp3.ktype
          _vtype163= rtmp3.vtype
          _size161= rtmp3.size
          for (var _i165 = 0; _i165 < _size161; ++_i165)
          {
            key166 = null
            val167 = null
            key166 = input.readString()
            {
              var _size168 = 0
              var rtmp3
              val167 = []
              var _etype171 = 0
              rtmp3 = input.readListBegin()
              _etype171 = rtmp3.etype
              _size168 = rtmp3.size
              for (var _i172 = 0; _i172 < _size168; ++_i172)
              {
                var elem173 = null
                elem173 = new ttypes.ColumnOrSuperColumn()
                elem173.read(input)
                val167.push(elem173)
              }
              input.readListEnd()
            }
            this.success[key166] = val167
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_slice_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_slice_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success))
      {
        for(var kiter174 in this.success)        {
          if (this.success.hasOwnProperty(kiter174))
          {
            var viter175 = this.success[kiter174]
            output.writeString(kiter174)
            {
              output.writeListBegin(Thrift.Type.STRUCT, viter175.length)
              {
                for(var iter176 in viter175)
                {
                  if (viter175.hasOwnProperty(iter176))
                  {
                    iter176=viter175[iter176]
                    iter176.write(output)
                  }
                }
              }
              output.writeListEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_count_args = function(args){
  this.keys = null
  this.column_parent = null
  this.predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.keys)
  this.keys = args.keys
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_multiget_count_args.prototype = {}
Cassandra_multiget_count_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.LIST) {
        {
          var _size177 = 0
          var rtmp3
          this.keys = []
          var _etype180 = 0
          rtmp3 = input.readListBegin()
          _etype180 = rtmp3.etype
          _size177 = rtmp3.size
          for (var _i181 = 0; _i181 < _size177; ++_i181)
          {
            var elem182 = null
            elem182 = input.readString()
            this.keys.push(elem182)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_count_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_count_args')
  if (null != this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1)
    {
      output.writeListBegin(Thrift.Type.STRING, this.keys.length)
      {
        for(var iter183 in this.keys)
        {
          if (this.keys.hasOwnProperty(iter183))
          {
            iter183=this.keys[iter183]
            output.writeString(iter183)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_multiget_count_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_multiget_count_result.prototype = {}
Cassandra_multiget_count_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size184 = 0
          var rtmp3
          this.success = {}
          var _ktype185 = 0
          var _vtype186 = 0
          rtmp3 = input.readMapBegin()
          _ktype185= rtmp3.ktype
          _vtype186= rtmp3.vtype
          _size184= rtmp3.size
          for (var _i188 = 0; _i188 < _size184; ++_i188)
          {
            key189 = null
            val190 = null
            key189 = input.readString()
            val190 = input.readI32()
            this.success[key189] = val190
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_multiget_count_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_multiget_count_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success))
      {
        for(var kiter191 in this.success)        {
          if (this.success.hasOwnProperty(kiter191))
          {
            var viter192 = this.success[kiter191]
            output.writeString(kiter191)
            output.writeI32(viter192)
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_range_slices_args = function(args){
  this.column_parent = null
  this.predicate = null
  this.range = null
  this.consistency_level = 1
if( args != null ){  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.predicate)
  this.predicate = args.predicate
  if (null != args.range)
  this.range = args.range
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_range_slices_args.prototype = {}
Cassandra_get_range_slices_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate()
        this.predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange()
        this.range.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_range_slices_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_range_slices_args')
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 2)
    this.predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.range) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 3)
    this.range.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_range_slices_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_range_slices_result.prototype = {}
Cassandra_get_range_slices_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size193 = 0
          var rtmp3
          this.success = []
          var _etype196 = 0
          rtmp3 = input.readListBegin()
          _etype196 = rtmp3.etype
          _size193 = rtmp3.size
          for (var _i197 = 0; _i197 < _size193; ++_i197)
          {
            var elem198 = null
            elem198 = new ttypes.KeySlice()
            elem198.read(input)
            this.success.push(elem198)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_range_slices_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_range_slices_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter199 in this.success)
        {
          if (this.success.hasOwnProperty(iter199))
          {
            iter199=this.success[iter199]
            iter199.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_indexed_slices_args = function(args){
  this.column_parent = null
  this.index_clause = null
  this.column_predicate = null
  this.consistency_level = 1
if( args != null ){  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.index_clause)
  this.index_clause = args.index_clause
  if (null != args.column_predicate)
  this.column_predicate = args.column_predicate
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_get_indexed_slices_args.prototype = {}
Cassandra_get_indexed_slices_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.index_clause = new ttypes.IndexClause()
        this.index_clause.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column_predicate = new ttypes.SlicePredicate()
        this.column_predicate.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_indexed_slices_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_indexed_slices_args')
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.index_clause) {
    output.writeFieldBegin('index_clause', Thrift.Type.STRUCT, 2)
    this.index_clause.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column_predicate) {
    output.writeFieldBegin('column_predicate', Thrift.Type.STRUCT, 3)
    this.column_predicate.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_get_indexed_slices_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_get_indexed_slices_result.prototype = {}
Cassandra_get_indexed_slices_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size200 = 0
          var rtmp3
          this.success = []
          var _etype203 = 0
          rtmp3 = input.readListBegin()
          _etype203 = rtmp3.etype
          _size200 = rtmp3.size
          for (var _i204 = 0; _i204 < _size200; ++_i204)
          {
            var elem205 = null
            elem205 = new ttypes.KeySlice()
            elem205.read(input)
            this.success.push(elem205)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_get_indexed_slices_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_get_indexed_slices_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter206 in this.success)
        {
          if (this.success.hasOwnProperty(iter206))
          {
            iter206=this.success[iter206]
            iter206.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_insert_args = function(args){
  this.key = null
  this.column_parent = null
  this.column = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.column)
  this.column = args.column
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_insert_args.prototype = {}
Cassandra_insert_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column()
        this.column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_insert_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_insert_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3)
    this.column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_insert_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_insert_result.prototype = {}
Cassandra_insert_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_insert_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_insert_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_add_args = function(args){
  this.key = null
  this.column_parent = null
  this.column = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_parent)
  this.column_parent = args.column_parent
  if (null != args.column)
  this.column = args.column
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_add_args.prototype = {}
Cassandra_add_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent()
        this.column_parent.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.CounterColumn()
        this.column.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_add_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_add_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2)
    this.column_parent.write(output)
    output.writeFieldEnd()
  }
  if (null != this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3)
    this.column.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_add_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_add_result.prototype = {}
Cassandra_add_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_add_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_add_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_args = function(args){
  this.key = null
  this.column_path = null
  this.timestamp = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.column_path)
  this.column_path = args.column_path
  if (null != args.timestamp)
  this.timestamp = args.timestamp
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_remove_args.prototype = {}
Cassandra_remove_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath()
        this.column_path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2)
    this.column_path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3)
    output.writeI64(this.timestamp)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_remove_result.prototype = {}
Cassandra_remove_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_counter_args = function(args){
  this.key = null
  this.path = null
  this.consistency_level = 1
if( args != null ){  if (null != args.key)
  this.key = args.key
  if (null != args.path)
  this.path = args.path
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_remove_counter_args.prototype = {}
Cassandra_remove_counter_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.path = new ttypes.ColumnPath()
        this.path.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_counter_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_counter_args')
  if (null != this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1)
    output.writeString(this.key)
    output.writeFieldEnd()
  }
  if (null != this.path) {
    output.writeFieldBegin('path', Thrift.Type.STRUCT, 2)
    this.path.write(output)
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_remove_counter_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_remove_counter_result.prototype = {}
Cassandra_remove_counter_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_remove_counter_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_remove_counter_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_batch_mutate_args = function(args){
  this.mutation_map = null
  this.consistency_level = 1
if( args != null ){  if (null != args.mutation_map)
  this.mutation_map = args.mutation_map
  if (null != args.consistency_level)
  this.consistency_level = args.consistency_level
}}
Cassandra_batch_mutate_args.prototype = {}
Cassandra_batch_mutate_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.MAP) {
        {
          var _size207 = 0
          var rtmp3
          this.mutation_map = {}
          var _ktype208 = 0
          var _vtype209 = 0
          rtmp3 = input.readMapBegin()
          _ktype208= rtmp3.ktype
          _vtype209= rtmp3.vtype
          _size207= rtmp3.size
          for (var _i211 = 0; _i211 < _size207; ++_i211)
          {
            key212 = null
            val213 = null
            key212 = input.readString()
            {
              var _size214 = 0
              var rtmp3
              val213 = {}
              var _ktype215 = 0
              var _vtype216 = 0
              rtmp3 = input.readMapBegin()
              _ktype215= rtmp3.ktype
              _vtype216= rtmp3.vtype
              _size214= rtmp3.size
              for (var _i218 = 0; _i218 < _size214; ++_i218)
              {
                key219 = null
                val220 = null
                key219 = input.readString()
                {
                  var _size221 = 0
                  var rtmp3
                  val220 = []
                  var _etype224 = 0
                  rtmp3 = input.readListBegin()
                  _etype224 = rtmp3.etype
                  _size221 = rtmp3.size
                  for (var _i225 = 0; _i225 < _size221; ++_i225)
                  {
                    var elem226 = null
                    elem226 = new ttypes.Mutation()
                    elem226.read(input)
                    val220.push(elem226)
                  }
                  input.readListEnd()
                }
                val213[key219] = val220
              }
              input.readMapEnd()
            }
            this.mutation_map[key212] = val213
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_batch_mutate_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_batch_mutate_args')
  if (null != this.mutation_map) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map))
      {
        for(var kiter227 in this.mutation_map)        {
          if (this.mutation_map.hasOwnProperty(kiter227))
          {
            var viter228 = this.mutation_map[kiter227]
            output.writeString(kiter227)
            {
              output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter228))
              {
                for(var kiter229 in viter228)                {
                  if (viter228.hasOwnProperty(kiter229))
                  {
                    var viter230 = viter228[kiter229]
                    output.writeString(kiter229)
                    {
                      output.writeListBegin(Thrift.Type.STRUCT, viter230.length)
                      {
                        for(var iter231 in viter230)
                        {
                          if (viter230.hasOwnProperty(iter231))
                          {
                            iter231=viter230[iter231]
                            iter231.write(output)
                          }
                        }
                      }
                      output.writeListEnd()
                    }
                  }
                }
              }
              output.writeMapEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2)
    output.writeI32(this.consistency_level)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_batch_mutate_result = function(args){
  this.ire = null
  this.ue = null
  this.te = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
}}
Cassandra_batch_mutate_result.prototype = {}
Cassandra_batch_mutate_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_batch_mutate_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_batch_mutate_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_truncate_args = function(args){
  this.cfname = null
if( args != null ){  if (null != args.cfname)
  this.cfname = args.cfname
}}
Cassandra_truncate_args.prototype = {}
Cassandra_truncate_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.cfname = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_truncate_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_truncate_args')
  if (null != this.cfname) {
    output.writeFieldBegin('cfname', Thrift.Type.STRING, 1)
    output.writeString(this.cfname)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_truncate_result = function(args){
  this.ire = null
  this.ue = null
if( args != null ){  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
}}
Cassandra_truncate_result.prototype = {}
Cassandra_truncate_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_truncate_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_truncate_result')
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_schema_versions_args = function(args){
}
Cassandra_describe_schema_versions_args.prototype = {}
Cassandra_describe_schema_versions_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_schema_versions_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_schema_versions_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_schema_versions_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_schema_versions_result.prototype = {}
Cassandra_describe_schema_versions_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.MAP) {
        {
          var _size232 = 0
          var rtmp3
          this.success = {}
          var _ktype233 = 0
          var _vtype234 = 0
          rtmp3 = input.readMapBegin()
          _ktype233= rtmp3.ktype
          _vtype234= rtmp3.vtype
          _size232= rtmp3.size
          for (var _i236 = 0; _i236 < _size232; ++_i236)
          {
            key237 = null
            val238 = null
            key237 = input.readString()
            {
              var _size239 = 0
              var rtmp3
              val238 = []
              var _etype242 = 0
              rtmp3 = input.readListBegin()
              _etype242 = rtmp3.etype
              _size239 = rtmp3.size
              for (var _i243 = 0; _i243 < _size239; ++_i243)
              {
                var elem244 = null
                elem244 = input.readString()
                val238.push(elem244)
              }
              input.readListEnd()
            }
            this.success[key237] = val238
          }
          input.readMapEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_schema_versions_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_schema_versions_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0)
    {
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success))
      {
        for(var kiter245 in this.success)        {
          if (this.success.hasOwnProperty(kiter245))
          {
            var viter246 = this.success[kiter245]
            output.writeString(kiter245)
            {
              output.writeListBegin(Thrift.Type.STRING, viter246.length)
              {
                for(var iter247 in viter246)
                {
                  if (viter246.hasOwnProperty(iter247))
                  {
                    iter247=viter246[iter247]
                    output.writeString(iter247)
                  }
                }
              }
              output.writeListEnd()
            }
          }
        }
      }
      output.writeMapEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspaces_args = function(args){
}
Cassandra_describe_keyspaces_args.prototype = {}
Cassandra_describe_keyspaces_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspaces_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspaces_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspaces_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_keyspaces_result.prototype = {}
Cassandra_describe_keyspaces_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size248 = 0
          var rtmp3
          this.success = []
          var _etype251 = 0
          rtmp3 = input.readListBegin()
          _etype251 = rtmp3.etype
          _size248 = rtmp3.size
          for (var _i252 = 0; _i252 < _size248; ++_i252)
          {
            var elem253 = null
            elem253 = new ttypes.KsDef()
            elem253.read(input)
            this.success.push(elem253)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspaces_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspaces_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter254 in this.success)
        {
          if (this.success.hasOwnProperty(iter254))
          {
            iter254=this.success[iter254]
            iter254.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_cluster_name_args = function(args){
}
Cassandra_describe_cluster_name_args.prototype = {}
Cassandra_describe_cluster_name_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_cluster_name_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_cluster_name_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_cluster_name_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_cluster_name_result.prototype = {}
Cassandra_describe_cluster_name_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_cluster_name_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_cluster_name_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_version_args = function(args){
}
Cassandra_describe_version_args.prototype = {}
Cassandra_describe_version_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_version_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_version_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_version_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_version_result.prototype = {}
Cassandra_describe_version_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_version_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_version_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_ring_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_describe_ring_args.prototype = {}
Cassandra_describe_ring_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_ring_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_ring_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_ring_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_ring_result.prototype = {}
Cassandra_describe_ring_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size255 = 0
          var rtmp3
          this.success = []
          var _etype258 = 0
          rtmp3 = input.readListBegin()
          _etype258 = rtmp3.etype
          _size255 = rtmp3.size
          for (var _i259 = 0; _i259 < _size255; ++_i259)
          {
            var elem260 = null
            elem260 = new ttypes.TokenRange()
            elem260.read(input)
            this.success.push(elem260)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_ring_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_ring_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length)
      {
        for(var iter261 in this.success)
        {
          if (this.success.hasOwnProperty(iter261))
          {
            iter261=this.success[iter261]
            iter261.write(output)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_partitioner_args = function(args){
}
Cassandra_describe_partitioner_args.prototype = {}
Cassandra_describe_partitioner_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_partitioner_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_partitioner_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_partitioner_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_partitioner_result.prototype = {}
Cassandra_describe_partitioner_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_partitioner_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_partitioner_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_snitch_args = function(args){
}
Cassandra_describe_snitch_args.prototype = {}
Cassandra_describe_snitch_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_snitch_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_snitch_args')
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_snitch_result = function(args){
  this.success = null
if( args != null ){  if (null != args.success)
  this.success = args.success
}}
Cassandra_describe_snitch_result.prototype = {}
Cassandra_describe_snitch_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_snitch_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_snitch_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_describe_keyspace_args.prototype = {}
Cassandra_describe_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_keyspace_result = function(args){
  this.success = null
  this.nfe = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.nfe)
  this.nfe = args.nfe
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_keyspace_result.prototype = {}
Cassandra_describe_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.KsDef()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException()
        this.nfe.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1)
    this.nfe.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 2)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_splits_args = function(args){
  this.cfName = null
  this.start_token = null
  this.end_token = null
  this.keys_per_split = null
if( args != null ){  if (null != args.cfName)
  this.cfName = args.cfName
  if (null != args.start_token)
  this.start_token = args.start_token
  if (null != args.end_token)
  this.end_token = args.end_token
  if (null != args.keys_per_split)
  this.keys_per_split = args.keys_per_split
}}
Cassandra_describe_splits_args.prototype = {}
Cassandra_describe_splits_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_splits_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_splits_args')
  if (null != this.cfName) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1)
    output.writeString(this.cfName)
    output.writeFieldEnd()
  }
  if (null != this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2)
    output.writeString(this.start_token)
    output.writeFieldEnd()
  }
  if (null != this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3)
    output.writeString(this.end_token)
    output.writeFieldEnd()
  }
  if (null != this.keys_per_split) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4)
    output.writeI32(this.keys_per_split)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_describe_splits_result = function(args){
  this.success = null
  this.ire = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
}}
Cassandra_describe_splits_result.prototype = {}
Cassandra_describe_splits_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.LIST) {
        {
          var _size262 = 0
          var rtmp3
          this.success = []
          var _etype265 = 0
          rtmp3 = input.readListBegin()
          _etype265 = rtmp3.etype
          _size262 = rtmp3.size
          for (var _i266 = 0; _i266 < _size262; ++_i266)
          {
            var elem267 = null
            elem267 = input.readString()
            this.success.push(elem267)
          }
          input.readListEnd()
        }
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_describe_splits_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_describe_splits_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0)
    {
      output.writeListBegin(Thrift.Type.STRING, this.success.length)
      {
        for(var iter268 in this.success)
        {
          if (this.success.hasOwnProperty(iter268))
          {
            iter268=this.success[iter268]
            output.writeString(iter268)
          }
        }
      }
      output.writeListEnd()
    }
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_column_family_args = function(args){
  this.cf_def = null
if( args != null ){  if (null != args.cf_def)
  this.cf_def = args.cf_def
}}
Cassandra_system_add_column_family_args.prototype = {}
Cassandra_system_add_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef()
        this.cf_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_column_family_args')
  if (null != this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1)
    this.cf_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_column_family_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_add_column_family_result.prototype = {}
Cassandra_system_add_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_column_family_args = function(args){
  this.column_family = null
if( args != null ){  if (null != args.column_family)
  this.column_family = args.column_family
}}
Cassandra_system_drop_column_family_args.prototype = {}
Cassandra_system_drop_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_column_family_args')
  if (null != this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1)
    output.writeString(this.column_family)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_column_family_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_drop_column_family_result.prototype = {}
Cassandra_system_drop_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_keyspace_args = function(args){
  this.ks_def = null
if( args != null ){  if (null != args.ks_def)
  this.ks_def = args.ks_def
}}
Cassandra_system_add_keyspace_args.prototype = {}
Cassandra_system_add_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef()
        this.ks_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_keyspace_args')
  if (null != this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1)
    this.ks_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_add_keyspace_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_add_keyspace_result.prototype = {}
Cassandra_system_add_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_add_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_add_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_keyspace_args = function(args){
  this.keyspace = null
if( args != null ){  if (null != args.keyspace)
  this.keyspace = args.keyspace
}}
Cassandra_system_drop_keyspace_args.prototype = {}
Cassandra_system_drop_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_keyspace_args')
  if (null != this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1)
    output.writeString(this.keyspace)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_drop_keyspace_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_drop_keyspace_result.prototype = {}
Cassandra_system_drop_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_drop_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_drop_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_keyspace_args = function(args){
  this.ks_def = null
if( args != null ){  if (null != args.ks_def)
  this.ks_def = args.ks_def
}}
Cassandra_system_update_keyspace_args.prototype = {}
Cassandra_system_update_keyspace_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef()
        this.ks_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_keyspace_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_keyspace_args')
  if (null != this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1)
    this.ks_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_keyspace_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_update_keyspace_result.prototype = {}
Cassandra_system_update_keyspace_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_keyspace_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_keyspace_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_column_family_args = function(args){
  this.cf_def = null
if( args != null ){  if (null != args.cf_def)
  this.cf_def = args.cf_def
}}
Cassandra_system_update_column_family_args.prototype = {}
Cassandra_system_update_column_family_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef()
        this.cf_def.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_column_family_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_column_family_args')
  if (null != this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1)
    this.cf_def.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_system_update_column_family_result = function(args){
  this.success = null
  this.ire = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_system_update_column_family_result.prototype = {}
Cassandra_system_update_column_family_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_system_update_column_family_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_system_update_column_family_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0)
    output.writeString(this.success)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_execute_cql_query_args = function(args){
  this.query = null
  this.compression = null
if( args != null ){  if (null != args.query)
  this.query = args.query
  if (null != args.compression)
  this.compression = args.compression
}}
Cassandra_execute_cql_query_args.prototype = {}
Cassandra_execute_cql_query_args.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 1:      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString()
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32()
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_execute_cql_query_args.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_execute_cql_query_args')
  if (null != this.query) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1)
    output.writeString(this.query)
    output.writeFieldEnd()
  }
  if (null != this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2)
    output.writeI32(this.compression)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var Cassandra_execute_cql_query_result = function(args){
  this.success = null
  this.ire = null
  this.ue = null
  this.te = null
  this.sde = null
if( args != null ){  if (null != args.success)
  this.success = args.success
  if (null != args.ire)
  this.ire = args.ire
  if (null != args.ue)
  this.ue = args.ue
  if (null != args.te)
  this.te = args.te
  if (null != args.sde)
  this.sde = args.sde
}}
Cassandra_execute_cql_query_result.prototype = {}
Cassandra_execute_cql_query_result.prototype.read = function(input){ 
  var ret = input.readStructBegin()
  while (1) 
  {
    var ret = input.readFieldBegin()
    var fname = ret.fname
    var ftype = ret.ftype
    var fid   = ret.fid
    if (ftype == Thrift.Type.STOP) 
      break
    switch(fid)
    {
      case 0:      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult()
        this.success.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 1:      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException()
        this.ire.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 2:      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException()
        this.ue.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 3:      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException()
        this.te.read(input)
      } else {
        input.skip(ftype)
      }
      break
      case 4:      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException()
        this.sde.read(input)
      } else {
        input.skip(ftype)
      }
      break
      default:
        input.skip(ftype)
    }
    input.readFieldEnd()
  }
  input.readStructEnd()
  return
}

Cassandra_execute_cql_query_result.prototype.write = function(output){ 
  output.writeStructBegin('Cassandra_execute_cql_query_result')
  if (null != this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0)
    this.success.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1)
    this.ire.write(output)
    output.writeFieldEnd()
  }
  if (null != this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2)
    this.ue.write(output)
    output.writeFieldEnd()
  }
  if (null != this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3)
    this.te.write(output)
    output.writeFieldEnd()
  }
  if (null != this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4)
    this.sde.write(output)
    output.writeFieldEnd()
  }
  output.writeFieldStop()
  output.writeStructEnd()
  return
}

var CassandraClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {}
}
CassandraClient.prototype = {}
CassandraClient.prototype.login = function(auth_request,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_login(auth_request)
}

CassandraClient.prototype.send_login = function(auth_request){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_login_args()
  args.auth_request = auth_request
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_login = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_login_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.authnx) {
    return callback(result.authnx);
  }
  if (null != result.authzx) {
    return callback(result.authzx);
  }
  callback(null)
}
CassandraClient.prototype.set_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_set_keyspace(keyspace)
}

CassandraClient.prototype.send_set_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_set_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_set_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_set_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  callback(null)
}
CassandraClient.prototype.get = function(key,column_path,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get(key, column_path, consistency_level)
}

CassandraClient.prototype.send_get = function(key,column_path,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_args()
  args.key = key
  args.column_path = column_path
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.nfe) {
    return callback(result.nfe);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get failed: unknown result");
}
CassandraClient.prototype.get_slice = function(key,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_slice(key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_slice = function(key,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_slice_args()
  args.key = key
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_slice_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_slice failed: unknown result");
}
CassandraClient.prototype.get_count = function(key,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_count(key, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_get_count = function(key,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_count_args()
  args.key = key
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_count_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_count failed: unknown result");
}
CassandraClient.prototype.multiget_slice = function(keys,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_multiget_slice(keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_slice = function(keys,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_multiget_slice_args()
  args.keys = keys
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_multiget_slice_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("multiget_slice failed: unknown result");
}
CassandraClient.prototype.multiget_count = function(keys,column_parent,predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_multiget_count(keys, column_parent, predicate, consistency_level)
}

CassandraClient.prototype.send_multiget_count = function(keys,column_parent,predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_count', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_multiget_count_args()
  args.keys = keys
  args.column_parent = column_parent
  args.predicate = predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_multiget_count = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_multiget_count_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("multiget_count failed: unknown result");
}
CassandraClient.prototype.get_range_slices = function(column_parent,predicate,range,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_range_slices(column_parent, predicate, range, consistency_level)
}

CassandraClient.prototype.send_get_range_slices = function(column_parent,predicate,range,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_range_slices_args()
  args.column_parent = column_parent
  args.predicate = predicate
  args.range = range
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_range_slices_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_range_slices failed: unknown result");
}
CassandraClient.prototype.get_indexed_slices = function(column_parent,index_clause,column_predicate,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level)
}

CassandraClient.prototype.send_get_indexed_slices = function(column_parent,index_clause,column_predicate,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_indexed_slices', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_get_indexed_slices_args()
  args.column_parent = column_parent
  args.index_clause = index_clause
  args.column_predicate = column_predicate
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_get_indexed_slices = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_get_indexed_slices_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("get_indexed_slices failed: unknown result");
}
CassandraClient.prototype.insert = function(key,column_parent,column,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_insert(key, column_parent, column, consistency_level)
}

CassandraClient.prototype.send_insert = function(key,column_parent,column,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_insert_args()
  args.key = key
  args.column_parent = column_parent
  args.column = column
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_insert_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.add = function(key,column_parent,column,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_add(key, column_parent, column, consistency_level)
}

CassandraClient.prototype.send_add = function(key,column_parent,column,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('add', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_add_args()
  args.key = key
  args.column_parent = column_parent
  args.column = column
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_add = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_add_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.remove = function(key,column_path,timestamp,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_remove(key, column_path, timestamp, consistency_level)
}

CassandraClient.prototype.send_remove = function(key,column_path,timestamp,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_remove_args()
  args.key = key
  args.column_path = column_path
  args.timestamp = timestamp
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_remove_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.remove_counter = function(key,path,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_remove_counter(key, path, consistency_level)
}

CassandraClient.prototype.send_remove_counter = function(key,path,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove_counter', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_remove_counter_args()
  args.key = key
  args.path = path
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_remove_counter = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_remove_counter_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.batch_mutate = function(mutation_map,consistency_level,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_batch_mutate(mutation_map, consistency_level)
}

CassandraClient.prototype.send_batch_mutate = function(mutation_map,consistency_level){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_batch_mutate_args()
  args.mutation_map = mutation_map
  args.consistency_level = consistency_level
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_batch_mutate_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  callback(null)
}
CassandraClient.prototype.truncate = function(cfname,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_truncate(cfname)
}

CassandraClient.prototype.send_truncate = function(cfname){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('truncate', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_truncate_args()
  args.cfname = cfname
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_truncate = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_truncate_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  callback(null)
}
CassandraClient.prototype.describe_schema_versions = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_schema_versions()
}

CassandraClient.prototype.send_describe_schema_versions = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_schema_versions', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_schema_versions_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_schema_versions = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_schema_versions_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_schema_versions failed: unknown result");
}
CassandraClient.prototype.describe_keyspaces = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_keyspaces()
}

CassandraClient.prototype.send_describe_keyspaces = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_keyspaces_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_keyspaces_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_keyspaces failed: unknown result");
}
CassandraClient.prototype.describe_cluster_name = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_cluster_name()
}

CassandraClient.prototype.send_describe_cluster_name = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_cluster_name_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_cluster_name_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_cluster_name failed: unknown result");
}
CassandraClient.prototype.describe_version = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_version()
}

CassandraClient.prototype.send_describe_version = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_version_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_version_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_version failed: unknown result");
}
CassandraClient.prototype.describe_ring = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_ring(keyspace)
}

CassandraClient.prototype.send_describe_ring = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_ring_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_ring_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_ring failed: unknown result");
}
CassandraClient.prototype.describe_partitioner = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_partitioner()
}

CassandraClient.prototype.send_describe_partitioner = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_partitioner', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_partitioner_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_partitioner = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_partitioner_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_partitioner failed: unknown result");
}
CassandraClient.prototype.describe_snitch = function(callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_snitch()
}

CassandraClient.prototype.send_describe_snitch = function(){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_snitch', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_snitch_args()
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_snitch = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_snitch_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_snitch failed: unknown result");
}
CassandraClient.prototype.describe_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_keyspace(keyspace)
}

CassandraClient.prototype.send_describe_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.nfe) {
    return callback(result.nfe);
  }
  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_keyspace failed: unknown result");
}
CassandraClient.prototype.describe_splits = function(cfName,start_token,end_token,keys_per_split,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_describe_splits(cfName, start_token, end_token, keys_per_split)
}

CassandraClient.prototype.send_describe_splits = function(cfName,start_token,end_token,keys_per_split){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_describe_splits_args()
  args.cfName = cfName
  args.start_token = start_token
  args.end_token = end_token
  args.keys_per_split = keys_per_split
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_describe_splits_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("describe_splits failed: unknown result");
}
CassandraClient.prototype.system_add_column_family = function(cf_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_add_column_family(cf_def)
}

CassandraClient.prototype.send_system_add_column_family = function(cf_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_add_column_family_args()
  args.cf_def = cf_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_add_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_add_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_add_column_family failed: unknown result");
}
CassandraClient.prototype.system_drop_column_family = function(column_family,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_drop_column_family(column_family)
}

CassandraClient.prototype.send_system_drop_column_family = function(column_family){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_drop_column_family_args()
  args.column_family = column_family
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_drop_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_drop_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_drop_column_family failed: unknown result");
}
CassandraClient.prototype.system_add_keyspace = function(ks_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_add_keyspace(ks_def)
}

CassandraClient.prototype.send_system_add_keyspace = function(ks_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_add_keyspace_args()
  args.ks_def = ks_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_add_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_add_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_add_keyspace failed: unknown result");
}
CassandraClient.prototype.system_drop_keyspace = function(keyspace,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_drop_keyspace(keyspace)
}

CassandraClient.prototype.send_system_drop_keyspace = function(keyspace){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_drop_keyspace_args()
  args.keyspace = keyspace
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_drop_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_drop_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_drop_keyspace failed: unknown result");
}
CassandraClient.prototype.system_update_keyspace = function(ks_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_update_keyspace(ks_def)
}

CassandraClient.prototype.send_system_update_keyspace = function(ks_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_keyspace', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_update_keyspace_args()
  args.ks_def = ks_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_update_keyspace = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_update_keyspace_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_update_keyspace failed: unknown result");
}
CassandraClient.prototype.system_update_column_family = function(cf_def,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_system_update_column_family(cf_def)
}

CassandraClient.prototype.send_system_update_column_family = function(cf_def){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_column_family', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_system_update_column_family_args()
  args.cf_def = cf_def
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_system_update_column_family = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_system_update_column_family_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("system_update_column_family failed: unknown result");
}
CassandraClient.prototype.execute_cql_query = function(query,compression,callback){
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
    this.send_execute_cql_query(query, compression)
}

CassandraClient.prototype.send_execute_cql_query = function(query,compression){
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_cql_query', Thrift.MessageType.CALL, this.seqid)
  var args = new Cassandra_execute_cql_query_args()
  args.query = query
  args.compression = compression
  args.write(output)
  output.writeMessageEnd()
  return this.output.flush()
}

CassandraClient.prototype.recv_execute_cql_query = function(input,mtype,rseqid){
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException()
    x.read(input)
    input.readMessageEnd()
    return callback(x);
  }
  var result = new Cassandra_execute_cql_query_result()
  result.read(input)
  input.readMessageEnd()

  if (null != result.ire) {
    return callback(result.ire);
  }
  if (null != result.ue) {
    return callback(result.ue);
  }
  if (null != result.te) {
    return callback(result.te);
  }
  if (null != result.sde) {
    return callback(result.sde);
  }
  if (null != result.success ) {
    return callback(null, result.success);
  }
  return callback("execute_cql_query failed: unknown result");
}
var CassandraProcessor = exports.Processor = function(handler) {
  this._handler = handler
}
CassandraProcessor.prototype.process = function(input, output) {
  var r = input.readMessageBegin()
  if (this['process_' + r.fname]) {
    return this['process_' + r.fname].call(this, r.rseqid, input, output)
  } else {
    input.skip(Thrift.Type.STRUCT)
    input.readMessageEnd()
    var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname)
    output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid)
    x.write(output)
    output.writeMessageEnd()
    output.flush()
  }
}

CassandraProcessor.prototype.process_login = function(seqid, input, output) {
  var args = new Cassandra_login_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_login_result()
  this._handler.login(args.auth_request, function(success) {
    result.success = success
    output.writeMessageBegin("login", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_set_keyspace = function(seqid, input, output) {
  var args = new Cassandra_set_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_set_keyspace_result()
  this._handler.set_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("set_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get = function(seqid, input, output) {
  var args = new Cassandra_get_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_result()
  this._handler.get(args.key, args.column_path, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_slice = function(seqid, input, output) {
  var args = new Cassandra_get_slice_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_slice_result()
  this._handler.get_slice(args.key, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_slice", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_count = function(seqid, input, output) {
  var args = new Cassandra_get_count_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_count_result()
  this._handler.get_count(args.key, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_count", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_multiget_slice = function(seqid, input, output) {
  var args = new Cassandra_multiget_slice_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_multiget_slice_result()
  this._handler.multiget_slice(args.keys, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("multiget_slice", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_multiget_count = function(seqid, input, output) {
  var args = new Cassandra_multiget_count_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_multiget_count_result()
  this._handler.multiget_count(args.keys, args.column_parent, args.predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("multiget_count", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_range_slices = function(seqid, input, output) {
  var args = new Cassandra_get_range_slices_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_range_slices_result()
  this._handler.get_range_slices(args.column_parent, args.predicate, args.range, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_range_slices", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_get_indexed_slices = function(seqid, input, output) {
  var args = new Cassandra_get_indexed_slices_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_get_indexed_slices_result()
  this._handler.get_indexed_slices(args.column_parent, args.index_clause, args.column_predicate, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("get_indexed_slices", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_insert = function(seqid, input, output) {
  var args = new Cassandra_insert_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_insert_result()
  this._handler.insert(args.key, args.column_parent, args.column, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("insert", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_add = function(seqid, input, output) {
  var args = new Cassandra_add_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_add_result()
  this._handler.add(args.key, args.column_parent, args.column, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("add", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_remove = function(seqid, input, output) {
  var args = new Cassandra_remove_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_remove_result()
  this._handler.remove(args.key, args.column_path, args.timestamp, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_remove_counter = function(seqid, input, output) {
  var args = new Cassandra_remove_counter_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_remove_counter_result()
  this._handler.remove_counter(args.key, args.path, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("remove_counter", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_batch_mutate_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_batch_mutate_result()
  this._handler.batch_mutate(args.mutation_map, args.consistency_level, function(success) {
    result.success = success
    output.writeMessageBegin("batch_mutate", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_truncate = function(seqid, input, output) {
  var args = new Cassandra_truncate_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_truncate_result()
  this._handler.truncate(args.cfname, function(success) {
    result.success = success
    output.writeMessageBegin("truncate", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_schema_versions = function(seqid, input, output) {
  var args = new Cassandra_describe_schema_versions_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_schema_versions_result()
  this._handler.describe_schema_versions(function(success) {
    result.success = success
    output.writeMessageBegin("describe_schema_versions", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_keyspaces = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspaces_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_keyspaces_result()
  this._handler.describe_keyspaces(function(success) {
    result.success = success
    output.writeMessageBegin("describe_keyspaces", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_cluster_name = function(seqid, input, output) {
  var args = new Cassandra_describe_cluster_name_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_cluster_name_result()
  this._handler.describe_cluster_name(function(success) {
    result.success = success
    output.writeMessageBegin("describe_cluster_name", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_version = function(seqid, input, output) {
  var args = new Cassandra_describe_version_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_version_result()
  this._handler.describe_version(function(success) {
    result.success = success
    output.writeMessageBegin("describe_version", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_ring = function(seqid, input, output) {
  var args = new Cassandra_describe_ring_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_ring_result()
  this._handler.describe_ring(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("describe_ring", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_partitioner = function(seqid, input, output) {
  var args = new Cassandra_describe_partitioner_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_partitioner_result()
  this._handler.describe_partitioner(function(success) {
    result.success = success
    output.writeMessageBegin("describe_partitioner", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_snitch = function(seqid, input, output) {
  var args = new Cassandra_describe_snitch_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_snitch_result()
  this._handler.describe_snitch(function(success) {
    result.success = success
    output.writeMessageBegin("describe_snitch", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_keyspace = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_keyspace_result()
  this._handler.describe_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("describe_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_describe_splits = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_describe_splits_result()
  this._handler.describe_splits(args.cfName, args.start_token, args.end_token, args.keys_per_split, function(success) {
    result.success = success
    output.writeMessageBegin("describe_splits", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_add_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_add_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_add_column_family_result()
  this._handler.system_add_column_family(args.cf_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_add_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_drop_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_drop_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_drop_column_family_result()
  this._handler.system_drop_column_family(args.column_family, function(success) {
    result.success = success
    output.writeMessageBegin("system_drop_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_add_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_add_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_add_keyspace_result()
  this._handler.system_add_keyspace(args.ks_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_add_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_drop_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_drop_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_drop_keyspace_result()
  this._handler.system_drop_keyspace(args.keyspace, function(success) {
    result.success = success
    output.writeMessageBegin("system_drop_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_update_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_update_keyspace_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_update_keyspace_result()
  this._handler.system_update_keyspace(args.ks_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_update_keyspace", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_system_update_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_update_column_family_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_system_update_column_family_result()
  this._handler.system_update_column_family(args.cf_def, function(success) {
    result.success = success
    output.writeMessageBegin("system_update_column_family", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

CassandraProcessor.prototype.process_execute_cql_query = function(seqid, input, output) {
  var args = new Cassandra_execute_cql_query_args()
  args.read(input)
  input.readMessageEnd()
  var result = new Cassandra_execute_cql_query_result()
  this._handler.execute_cql_query(args.query, args.compression, function(success) {
    result.success = success
    output.writeMessageBegin("execute_cql_query", Thrift.MessageType.REPLY, seqid)
    result.write(output)
    output.writeMessageEnd()
    output.flush()
  })
}

